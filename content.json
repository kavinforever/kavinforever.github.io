[{"title":"从你的全世界路过","date":"2017-02-14T14:58:56.000Z","path":"2017/02/14/从你的全世界路过/","text":"从你的全世界路过 路过了好多人的世界 有的人就真的只是路过 有的人即使是路过也会想要回头去永久的停留 我去路过别人的旅程 别人也从我这里路过 你的脚印很深 我的脚印很浅 浪一打 我的脚印没有 风一吹 你的脚印成了烙印","tags":[{"name":"从你的全世界路过","slug":"从你的全世界路过","permalink":"http://kavinforever.github.io/tags/从你的全世界路过/"},{"name":"随笔","slug":"随笔","permalink":"http://kavinforever.github.io/tags/随笔/"}]},{"title":"圣杯布局和双飞翼布局","date":"2017-02-08T11:50:48.000Z","path":"2017/02/08/圣杯布局和双飞翼布局/","text":"简介 随意看到一篇知乎文章，讲解圣杯布局和双飞翼布局的，感觉讲的不太全，而且没有代码演示，这里对这两种布局进行一下总结。 一、来源和对比圣杯布局的来历是2006年发在a list part上的这篇文章：In Search of the Holy Grail · An A List Apart Article 双飞翼据考源自淘宝UED的玉伯大大，应该是一种页面的形象的表达。 圣杯布局和双飞翼布局，他们的都要求三列布局，中间宽度自适应，两边定宽，这样做的优势是重要的东西放在文档流前面可以优先渲染，而双飞翼布局是对圣杯布局的一种改良。 二、圣杯布局2.1 创建框架123&lt;div id=\"header\"&gt;&lt;/div&gt;&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;div id=\"footer\"&gt;&lt;/div&gt; 1234#container &#123; padding-left: 200px; /* LC width */ padding-right: 150px; /* RC width */&#125; 2.2 增加左右中三列1234567&lt;div id=\"header\"&gt;&lt;/div&gt;&lt;div id=\"container\"&gt; &lt;div id=\"center\" class=\"column\"&gt;&lt;/div&gt; &lt;div id=\"left\" class=\"column\"&gt;&lt;/div&gt; &lt;div id=\"right\" class=\"column\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=\"footer\"&gt;&lt;/div&gt; 给左侧div块设置宽度为200，右侧div块宽度为150，中间的宽度为100%。三个div的属性都是浮动属性，脱离文档流的存在。123456789101112131415#container .column &#123; float: left;&#125;#center &#123; width: 100%;&#125;#left &#123; width: 200px; /* LC width */&#125;#right &#123; width: 150px; /* RC width */&#125;#footer &#123; clear: both;&#125; 中间div的100%宽度对应的是父容器container的内容区域宽度（去除padding）。所以左右两侧都被挤下去了。三个div的顺序一定要保证center在第一个！！ 2.3 把左侧边块放入指定空间1234#left &#123; width: 200px; /* LC width */ margin-left: -100%; &#125; !!@注意margin-left的宽度是相对于和当前元素在同个父级元素下的其他脱离文档流的元素。所以这里的100%是相对于中间center的宽度 为了不让左列压盖住center列，所以使用相对定位，指定左列宽度的偏移值来达到效果。123456789#container .columns &#123; float: left; position: relative;&#125;#left &#123; width: 200px; /* LC width */ margin-left: -100%; right: 200px; /* LC width */&#125; ``` 2.4 把右侧边块放入指定空间1234#right &#123; width: 150px; /* RC width */ margin-right: -150px; /* RC width */&#125; 2.5 中间center被左右两列挡住了怎么办容器的左右各padding左右列的宽度，这样center的宽度内容就不会被压盖1234#container &#123; padding-left: 200px; /* LC fullwidth */ padding-right: 190px; /* RC fullwidth + CC padding */&#125; 2.6 圣杯布局总览1234567&lt;div id=\"header\"&gt;&lt;/div&gt;&lt;div id=\"container\"&gt; &lt;div id=\"center\" class=\"column\"&gt;&lt;/div&gt; &lt;div id=\"left\" class=\"column\"&gt;&lt;/div&gt; &lt;div id=\"right\" class=\"column\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=\"footer\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930body &#123; min-width: 550px; /* 2x LC width + RC width */&#125;#container &#123; padding-left: 200px; /* LC width */ padding-right: 150px; /* RC width */&#125;#container .column &#123; position: relative; float: left;&#125;#center &#123; width: 100%;&#125;#left &#123; width: 200px; /* LC width */ right: 200px; /* LC width */ margin-left: -100%;&#125;#right &#123; width: 150px; /* RC width */ margin-right: -150px; /* RC width */&#125;#footer &#123; clear: both;&#125;/*** IE6 Fix ***/* html #left &#123; left: 150px; /* RC width */&#125; 在线demo样例：http://alistapart.com/d/holygrail/example_1.html 三、双飞翼布局在不增加额外标签的情况下，圣杯布局已经非常完美，圣杯布局使用了相对定位，以后布局是有局限性的，而且宽度控制要改的地方也多，那么有没其他方法更加简洁方便呢？ 在淘宝UED探讨下，增加多一个div就可以不用相对布局了，只用到了浮动和负边距，这就是我们所说的双飞翼布局。 123456789101112&lt;div class=\"header\"&gt;Header&lt;/div&gt;&lt;div class=\"bd\"&gt; &lt;div id='center' class=\"column\"&gt; &lt;div class=\"inner\"&gt; Main &lt;/div&gt; &lt;/div&gt; &lt;div id='left' class=\"column\"&gt;Left&lt;/div&gt; &lt;div id='right' class=\"column\"&gt;Right &lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;Footer&lt;/div&gt; 样式：去掉了左右栏的相对定位，去掉包裹层padding，以中间栏新增div的margin代替1234567891011121314151617181920212223242526272829303132body &#123; padding: 0; margin: 0&#125;.header, .footer &#123; width: 100%; background: #666; height: 50px; clear: both;&#125;.column&#123; float:left;&#125;#center &#123; background: #D6D6D6; width: 100%; &#125;.inner &#123; margin-left: 150px; margin-right: 190px;&#125;#left &#123; background: #E79F6D; width: 150px; margin-left: -100%;&#125;#right &#123; background: #77BBDD; width: 190px; margin-left: -190px; &#125; 在线demohttps://jsfiddle.net/kavinforever/sxb7ccrf/ 四、参考文献 http://alistapart.com/article/holygrail CSS布局中圣杯布局与双飞翼布局的实现思路差异在哪里？ https://www.zhihu.com/question/21504052 双飞翼布局介绍-始于淘宝UED http://www.imooc.com/wenda/detail/254035 圣杯布局的实现过程 http://www.cnblogs.com/tinyphp/p/4742922.html 双飞翼布局和圣杯布局的对比 http://www.cnblogs.com/tinyphp/p/4743674.html","tags":[{"name":"css","slug":"css","permalink":"http://kavinforever.github.io/tags/css/"},{"name":"圣杯布局","slug":"圣杯布局","permalink":"http://kavinforever.github.io/tags/圣杯布局/"},{"name":"双飞翼布局","slug":"双飞翼布局","permalink":"http://kavinforever.github.io/tags/双飞翼布局/"},{"name":"相对定位","slug":"相对定位","permalink":"http://kavinforever.github.io/tags/相对定位/"}]},{"title":"精通CSS高级web解决方案读书笔记二","date":"2017-02-06T12:51:28.000Z","path":"2017/02/06/精通CSS高级web解决方案读书笔记二/","text":"简介 主要包含盒模型、定位。理解文档流的概念，理解绝对定位、浮动定位都不在文档流中。 第三章 可视化格式模型一、盒模型盒模型是css的基石，页面上的每个元素被看成矩形框，这个框由元素的内容、内边距、边框、外边距组成。 outline轮廓属性–绘制在元素框之上，不影响元素的大小和定位，不影响页面布局所以有助于修复bug！ width和height指的是内容区域的宽度和高度！ 二、外边距叠加只有普通文档流中块框的垂直外边距才会发生外边距叠加。行内框、浮动框或者绝对定位框之间的外边距不会叠加。 三、可视化格式模型块级元素：p、h1、div行内元素：strong、span可以通过display来改变框的类型 四、相对定位和绝对定位position：relative、absolute、fixed相对定位是自私的，无论元素是否移动还是会占据原来的空间； 绝对定位使得元素的位置与文档流无关，不占据空间，绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。 相对定位是“相对于”元素在文档流中的初始位置 绝对定位是“相对于”距离它最近的已定位祖先元素，不存在则是body 五、浮动定位浮动定位的框可以左右移动，直到它的外边缘碰到包含框或者另一个浮动框的边缘。","tags":[{"name":"css","slug":"css","permalink":"http://kavinforever.github.io/tags/css/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://kavinforever.github.io/tags/读书笔记/"},{"name":"盒模型","slug":"盒模型","permalink":"http://kavinforever.github.io/tags/盒模型/"},{"name":"定位","slug":"定位","permalink":"http://kavinforever.github.io/tags/定位/"},{"name":"文档流","slug":"文档流","permalink":"http://kavinforever.github.io/tags/文档流/"}]},{"title":"精通CSS高级web解决方案读书笔记一","date":"2017-02-01T04:10:40.000Z","path":"2017/02/01/精通CSS高级web解决方案读书笔记一/","text":"读书笔记 第一章 基础知识一、css的出现表现（css）与内容（html）的分离 不要使用表现性元素来命名，应该根据“它们是什么”来为元素命名，而不是根据“它们的外观如何”来命名。坏的命名red，好的命名error 二、使用id还是类类应用在概念上相似的元素，这些元素可以出现在同一个页面的多个位置ID应该应用于不同的唯一的元素 只有在绝对确定这个元素只会出现一次的情况下才使用ID。如果以后可能需要相似的元素，就使用类。 不要试图在每一个东西上都添加类！！（==多类症==） 三、DOCTYPEdtd(文档类型定义)是一组机器可读的规则，用这些规则来检查页面的有效性并采取相应的措施。DOCTYPE声明是指html文档开头处的一行两行代码，描述使用哪个dtd，但是html5就不需要特定dtd文件的url1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"lib/d3.v3.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"css/jquery.jqtimeline.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 第二章 为样式找到应用目标–各种选择器一、常用选择器 类型选择器 div p h1 后代选择器：由两个选择器之间的空格表示 .news p ID选择器 #container 类选择器 .news分析元素的差异性，如果元素的唯一差异只是在页面上的位置，那么不要给这些元素指定不同的类，而是将一个类应用于它们的祖先，然后后代选择器定位它们。 伪类 :hover 通用选择器 * 高级选择器 子选择器 后代选择器选择一个元素的所有的后代，而子选择器只选择元素的直接后代，即子元素。 #nav&gt;li 相邻同胞选择器 顶级标题后面一段粗体标识 123h2+p&#123; font-weight:bold;&#125; 属性选择器 对具有title属性的元素应用特殊的样式 二、层叠重要度和特殊性重要度： 标有！important的用户样式 标有！important的开发者样式 开发者样式 用户样式 浏览器、用户代理应用的样式 特殊性： 行内样式style 1000 ID选择器 100 类、伪类、属性选择器 10 类型选择器 1 三、继承不要把继承和层叠混为一谈！继承的定义是应用样式的元素的后代会继承样式的某些属性，例如颜色和字号。应用在元素上的任务样式会覆盖继承而来的样式。","tags":[{"name":"css","slug":"css","permalink":"http://kavinforever.github.io/tags/css/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://kavinforever.github.io/tags/读书笔记/"}]},{"title":"css实现三角形图形原理解析","date":"2016-10-13T21:06:19.000Z","path":"2016/10/14/css实现三角形图形原理解析/","text":"在写select组件的时候需要用css实现向上和向下的箭头，这个地方网上有很多的实现，但是想要了解具体的实现原理，因此写了这篇博客。 border属性的用法 border 四条边框设置 border-left 设置左边框，一般单独设置左边框样式使用 border-right 设置右边框，一般单独设置右边框样式使用 border-top 设置上边框，一般单独设置上边框样式使用 border-bottom 设置下边框，一般单独设置下边框样式使用,有时可将下边框样式作为CSS下划线效果应用 实现四个边框 1&lt;div class='wrap'&gt;我是一个居中的元素&lt;/div&gt; 12345678.wrap&#123; border-left:15px solid red; border-right:15px solid green; border-top:15px solid yellow; border-bottom:15px solid black; text-align:center; &#125; 实现效果如下： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='wrap'&gt;我是一个居中的元素&lt;/div&gt; &lt;br&gt; &lt;div class='wrap'&gt;&lt;/div&gt; &lt;div class=\"test-border-0\"&gt;&lt;/div&gt; &lt;div class=\"test-border-1\"&gt;&lt;/div&gt; &lt;br&gt; &lt;div class=\"test-border-2\"&gt;&lt;/div&gt; &lt;br&gt; &lt;div class=\"test-border-3\"&gt;&lt;/div&gt; &lt;br&gt; &lt;div class=\"test-border-4\"&gt;&lt;/div&gt; &lt;br&gt; &lt;div class=\"test-border-5\"&gt;&lt;/div&gt; &lt;br&gt; &lt;div class=\"test-border-6\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"css","slug":"css","permalink":"http://kavinforever.github.io/tags/css/"}]},{"title":"web跨域的几种实现方式","date":"2016-08-10T11:50:48.000Z","path":"2016/08/10/web跨域的几种实现方式/","text":"今天在为我们系统接入阿里域登录的时候遇到了跨域问题，以前在系统中都是后端设置允许跨域或者采用jsonp来实现跨域。这次从web端角度对常见的跨域问题进行总结，防止以后再遇到类似问题。 同源策略/SOP（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击 SOP要求两个通讯地址的协议、域名、端口号必须相同，否则两个地址的通讯将被浏览器视为不安全的，并被block下来。比如“http页面”和“https页面”属于不同协议；“qq.com”、“www.qq.com”、“a.qq.com”都属于不同域名（或主机）；“a.com”和“a.com:8000”属于不同端口号。这三种情况常规都是无法直接进行通讯的。 模拟不同源的实现可以采用iframe来实现：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模拟跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=&quot;http://baidu.com&quot;&gt;&lt;/iframe&gt;&lt;script&gt; window.frames[0].onload = function () &#123; alert(&quot;1&quot;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码在chrome中报错1Uncaught DOMException: Blocked a frame with origin &quot;https://www.baidu.com&quot; from accessing a cross-origin frame.(…) 即我们无法监听百度首页文档onload的事件，因为top窗口跟iframe窗体是不同源的。 #目录 # - 服务端设置CORS - XDR - withCredentials - HTML5解决方案 1. Cross-document messaging 2. WebSocket - JSONP - iframe形式 1. document.domain 2. location.hash 3. window.name - 其它形式 1. 服务器代理 2. flash socket 服务端设置CORS同域安全策略CORS（Cross-Origin Resource Sharing）是W3C在05年提出的跨域资源请求机制，它要求当前域（常规为存放资源的服务器）在响应报头添加Access-Control-Allow-Origin标签，从而允许指定域的站点访问当前域上的资源。服务端(node)1234567var http = require(\"http\");require(\"http\").createServer(function(req,res)&#123; //报头添加Access-Control-Allow-Origin标签，值为特定的URL或“*” //“*”表示允许所有域访问当前域 res.setHeader(\"Access-Control-Allow-Origin\",\"*\"); res.end(\"OK\");&#125;).listen(1234); 客户端12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CORS&lt;/title&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;catching data...&lt;/div&gt;&lt;script&gt; $.ajax(&#123; url:&quot;http://127.0.0.1:1234/&quot;, success:function(data)&#123; $(&quot;div&quot;).text(data) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果：运行客户端页面后，便能看到div内容成功变为服务端发来的“OK”，实现了两个不同域的页面间的通讯。通过上述代码我们也发现，CORS主要是在服务端上的实现（也不外乎是添加一个报头标签），客户端的实现跟常规的请求没啥出入。 不过CORS默认只支持GET/POST这两种http请求类型，如果要开启PUT/DELETE之类的方式，需要在服务端在添加一个”Access-Control-Allow-Methods”报头标签：12345678require(&quot;http&quot;).createServer(function(req,res)&#123; res.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1&quot;); res.setHeader( &quot;Access-Control-Allow-Methods&quot;, &quot;PUT, GET, POST, DELETE, HEAD, PATCH&quot; ); res.end(req.method+&quot; &quot;+req.url);&#125;).listen(1234); XDR恼人的IE8-是不支持上述的CORS滴，不过不走寻常路的巨硬在IE8开始引入了XDR(XDomainRequest)新特性（IE11已经不再支持该特性），它实现了CORS的部分规范，只支持GET/POST形式的请求。另外在协议部分只支持 http 和 https 。 在服务器端，依旧要求在响应报头添加”Access-Control-Allow-Methods”标签（这点跟CORS一致）。 在客户端，DR对象的使用方法与XHR对象非常相似，也是创建一个XDomainRequest的实例，调用open()方法，再调用send()方法。但与XHR对象的open()方法不同，XDR对象的open()方法只接收两个参数：请求的类型和URL，因为所有XDR请求都是异步执行的，不能用它来创建同步请求。 请求返回之后，会触发load事件，相应的数据也会保存在responseText属性中，如下所示：123456789var xdr = new XDomainRequest();xdr.onload = function() &#123; alert(xdr.responseText);&#125;;xdr.onerror = function() &#123; alert(&quot;一个错误发生了！&quot;);&#125;;xdr.open(&quot;get&quot;, &quot;http://127.0.0.1:1234/&quot;);xdr.send(null); 由于XDR实在太过时，这里不做太多介绍，了解下即可 withCredentials通过上述两种跨域介绍我们可以实现跨浏览器的跨域实现。withCredentials这种在请求头增加该属性的方法也是我在这次的项目中采用的方法。因为接入阿里登录系统其实是通过获取同域名的前一个重定向请求的cookie来发送跨域请求获得用户登录信息。12345678910111213141516171819function createCORSRequest(method, url) &#123; var xhr = new XMLHttpRequest(); if (\"withCredentials\" in xhr) &#123; // \"withCredentials\"属性是XMLHTTPRequest2中独有的 xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != \"undefined\") &#123; // 检测是否XDomainRequest可用 xhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; // 看起来CORS根本不被支持 xhr = null; &#125; return xhr;&#125;var xhr = createCORSRequest('GET', url);if (!xhr) &#123; throw new Error('CORS not supported');&#125; 标准的CORS请求不对cookies做任何事情，既不发送也不改变。如果希望改变这一情况，就需要将withCredentials设置为true。 另外，服务端在处理这一请求时，也需要将Access-Control-Allow-Credentials设置为true。这一点我们稍后来说。 withCredentials属性使得请求包含了远程域的所有cookies，但值得注意的是，这些cookies仍旧遵守“同域”的准则，因此从代码上你并不能从document.cookies或者回应HTTP头当中进行读取。 HTML5解决方案1. Cross-document messaging在 Cross-document messaging 中，我们可以使用 postMessage 方法和 onmessage 事件来实现不同域之间的通信，其中postMessage用于实时向接收信息的页面发送消息，其语法为：1otherWindow.postMessage(message, targetOrigin); 123otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 允许通信的域的url，“*”表示不作限制。 我们可以在父页面中嵌入不同域的子页面（iframe实现，而且常规会把它隐藏掉），在子页面调用 postMessage 方法向父页面发送数据：父页面a.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;postMessage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe style=&quot;display:none;&quot; id=&quot;ifr&quot; src=&quot;http://127.0.0.1:63342/cross/b.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;message&apos;, function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == &apos;http://127.0.0.1:63342&apos;) &#123; alert(event.data); // 弹出从子页面post过来的信息 &#125; &#125;, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 子页面b.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;子页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var ifr = window.parent; //获取父窗体 var targetOrigin = &apos;http://localhost:63342&apos;; // 若写成 http://127.0.0.1:10847 则将无法执行postMessage ifr.postMessage(&apos;这是传递给a.html的信息&apos;, targetOrigin);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. WebSocketweb sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。12345var socket = new WebSockt('ws://www.baidu.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125; JSONPJSONP包含两部分：回调函数和数据。回调函数是当响应到来时要放在当前页面被调用的函数。数据就是传入回调函数中的json数据，也就是回调函数的参数了。12345678910111213function handleResponse(response)&#123; console.log('The responsed data is: '+response.data);&#125;var script = document.createElement('script');script.src = 'http://www.baidu.com/json/?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild);/*handleResonse(&#123;\"data\": \"zhe\"&#125;)*///原理如下：//当我们通过script标签请求时//后台就会根据相应的参数(json,handleResponse)//来生成相应的json数据(handleResponse(&#123;\"data\": \"zhe\"&#125;))//最后这个返回的json数据(代码)就会被放在当前js文件中被执行//至此跨域通信完成 jsonp虽然很简单，但是有如下缺点：1）安全问题(请求代码中可能存在安全隐患)2）要确定jsonp请求是否失败并不容易 JSONP(JSON with Padding)是JSON的一种“使用模式”，主要是利用script标签不受同源策略限制的特性，向跨域的服务器请求并返回一段JSON数据。 常规前后端会约定好某个JSONP请求的callback名（比如随便起个名字“abc”），服务端返回的JSON数据会被这个callback名包裹起来，进而方便服务器区分收到的请求，也方便客户端区分其收到的响应数据。我们可以利用jQuery轻松实现JSONP：客户端123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP&lt;/title&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; $.ajax(&#123; url:&apos;http://127.0.0.1:1234/&apos;, dataType:&quot;jsonp&quot;, //告知jQ我们走的JSONP形式 jsonpCallback:&quot;abc&quot;, //callback名 success:function(data)&#123; console.log(data) &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端（访问地址http://127.0.0.1:1234/ ）：1234567891011121314151617181920/** * Created by leo.wz on 2016/8/10. */var http = require(&apos;http&apos;);var urllib = require(&apos;url&apos;);var data = &#123;&apos;name&apos;: &apos;vajoy&apos;, &apos;addr&apos;: &apos;shenzhen&apos;&#125;;http.createServer(function(req, res)&#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/plain&apos;&#125;); var params = urllib.parse(req.url, true); //console.log(params); if (params.query &amp;&amp; params.query.callback) &#123; //console.log(params.query.callback); var str = params.query.callback + &apos;(&apos; + JSON.stringify(data) + &apos;)&apos;;//jsonp res.end(str); &#125; else &#123; res.end(JSON.stringify(data));//普通的json &#125;&#125;).listen(1234) 客户端执行结果： 不过JSONP始终是无状态连接，不能获悉连接状态和错误事件，而且只能走GET的形式。 iframe形式在很久以前的石器时代，对于不支持 XMLHttpRequest 的浏览器的最佳回溯方法之一就是使用IFRAME对象，当然常规只是用它来实现流模式的Comet，而不是解决跨域通信的问题。 使用iframe跨域其实有点剑走偏锋的既视感，也存在一些限制性。下面均来介绍下。 1. document.domain该方法只适合主域相同但子域不同的情况，比如 www.a.com 和 script.a.com，我们只需要给这两个页面都加上一句 document.domain = ‘a.com’ ，就可以在其中一个页面嵌套另一个页面，然后进行窗体间的交互。1) 在www.a.com/a.html中：12345678910document.domain = 'a.com';var ifr = document.createElement('iframe');ifr.src = 'http://www.script.a.com/b.html';ifr.display = none;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; //在这里操作doc，也就是b.html ifr.onload = null;&#125;; 2) 在www.script.a.com/b.html中：1document.domain = 'a.com'; 这样在a的页面中就可以修改页面b的数据 2. location.hashlocation.hash/url hash 是个好东西，在之前我们曾利用avalon前端路由来实现简单的SPA页面（这篇文章），便是助力于location.hash。 利用url地址改变但不刷新页面的特性（在url： http://a.com#hello 中的 ‘#hello’ 就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递）和iframe，我们可以实现跨域传递简单信息。 不过这个实现略麻烦，常规我们会想，在a.html下嵌套一个不同域的b.html，然后 a 和 b 互相修改彼此的hash值，也不断监听自己的hash值，从而实现我们的需求。可惜的是，大部分浏览器不允许修改不同域的父窗体的hash值（parent.location.hash），也就是说a虽能修改b的hash值，但反过来由b修改a的hash值却不成立。 为了解除该限制，我们可以在b页面中增加一个和a同域的iframe（c.html）来做代理，这样b可以修改c，而c可以修改a（即修改parent.parent.location.hash，别忘了a和c同域哦）。下面直接模拟这三个页面，做到让b向a传输信息（当然本质上是b向c，c再向a传输）： 该方法优点是兼容较好，缺点却显而易见——可传递的数据类型、长度均受限，数据还是直接显示在url上的，不够安全。另外其实现也较麻烦，还要搞setInterval不断监听，跟轮询没区别了。 3. window.namewindow.name 的美妙之处在于，窗体的name值在页面跳转后依旧存在、保持原值（即使跳转的页面不同域），并且可以支持非常长的 name 值（2MB）。 其它形式1. 服务器代理页面直接向同域的服务端发请求，服务端进行跨域处理或爬虫后，再把数据返回给客户端页面。依旧用node/iojs来模拟服务端客户端：1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;proxy_test&lt;/title&gt; &lt;script&gt; var f = function(data)&#123; alert(data.name); &#125; var xhr = new XMLHttpRequest(); xhr.onload = function()&#123; alert(xhr.responseText); &#125;; xhr.open(&apos;POST&apos;, &apos;http://localhost:8888/proxy?http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer&apos;, true); xhr.send(&quot;f=json&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 服务端：1234567891011121314151617181920212223var proxyUrl = \"\"; if (req.url.indexOf('?') &gt; -1) &#123; proxyUrl = req.url.substr(req.url.indexOf('?') + 1); console.log(proxyUrl); &#125; if (req.method === 'GET') &#123; request.get(proxyUrl).pipe(res); &#125; else if (req.method === 'POST') &#123; var post = ''; //定义了一个post变量，用于暂存请求体的信息 req.on('data', function(chunk)&#123; //通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 post += chunk; &#125;); req.on('end', function()&#123; //在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 post = qs.parse(post); request(&#123; method: 'POST', url: proxyUrl, form: post &#125;).pipe(res); &#125;); &#125; 2. flash socket其实在前面介绍socket.io的时候就有提到，在不兼容WebSocket的浏览器下，socket.io会以flash socket或Comet的形式来兼容，而flash socket是支持跨域通信的形式，跟WebSocket一样走的TCP/IP套接字协议。具体的实现可参考Adobe官方文档，本文不赘述。 参考文献1.http://www.html5rocks.com/en/tutorials/cors/2.http://www.cnblogs.com/vajoy/p/4295825.html3.http://newhtml.net/using-cors/","tags":[{"name":"跨域","slug":"跨域","permalink":"http://kavinforever.github.io/tags/跨域/"},{"name":"josnp","slug":"josnp","permalink":"http://kavinforever.github.io/tags/josnp/"},{"name":"withCredentials","slug":"withCredentials","permalink":"http://kavinforever.github.io/tags/withCredentials/"},{"name":"代理","slug":"代理","permalink":"http://kavinforever.github.io/tags/代理/"},{"name":"javascript","slug":"javascript","permalink":"http://kavinforever.github.io/tags/javascript/"}]},{"title":"rem在前端开发中的应用","date":"2016-08-01T06:39:38.000Z","path":"2016/08/01/rem在前端开发中的应用/","text":"前段时间在练习地铁H5切图的过程中，尝试使用rem来进行css单位的设置，感觉rem是最适合web app的单位，没有之一。 目录： 1. CSS中的单位介绍 2. rem在移动端开发中的使用 3. 总结 4. 参考文档 一、CSS中的单位介绍1.1 像素的概念设备像素(device pixel):设备像素是物理概念，指的是设备中使用的物理像素。比如iPhone 5的分辨率640 x 1136px。 设备独立像素(device-independent pixels (dips))(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。 在PC端可以通过 screen.width/height 属性来获取设备独立像素值，在PC端这个值把它当成我们常说的屏幕分辨率（实际上它不是，但是由于在PC端设备像素和设备独立像素数值相等，才有这么一个不准确的说法）。 CSS像素(css pixel):CSS像素是Web编程的概念，指的是CSS样式代码中使用的逻辑像素。在CSS规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px是一个相对单位，相对的是设备像素(device pixel)。 比如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而CSS逻辑像素数为320 x 568px。 每英寸像素PPI&amp;&amp; 设备像素比DPI每英寸像素(pixel per inch,PPI):表示每英寸所拥有的像素(pixel)数目，数值越高，代表显示屏能够以越高的密度显示图像。要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。 以尺寸为4.7英寸、分辨率为1334*750的iphone6为例 设备像素比(device pixel ratio,DPI)：window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。 公式表示就是：window.devicePixelRatio = 物理像素 / dips以上计算出ppi是为了得到密度分界，获得默认缩放比例，即设备像素比。可以通过JavaScript 中的window.devicePixelRatio来获取设备中的像素比值。 ppi在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度（Apple给了它一个高大上的名字——Retina）。 获得设备像素比后，便可得知设备像素与CSS像素之间的比例。当这个比率为1:1时，使用1个设备像素显示1个CSS像素。当这个比率为2:1时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。 下面给出iphone各个信息的设备像素、css像素、设备像素比等参数具体可以参考http://screensiz.es/phone，有各种设备的详细参数。 分辨率分辨率：泛指量测或显示系统对细节的分辨能力。以PC屏幕，手机屏幕为例，分辨率1920*1080 是指屏幕纵向能显示1920个像素，横向能显示1080个像素。这里的像素指的是设备像素。 描述分辨率的单位有：dpi（点每英寸）、lpi（线每英寸）和ppi（像素 每英寸）。从技术角度说，“像素”只存在于电脑、手机显示领域，而“点”只出现于打印或印刷领域。对于web开发者，我们需要清楚ppi（ pixel per inch） 1.2 px介绍px是国内目前使用最多的css单位。在chrome浏览器下默认加载的字体大小是16px最小字体是12px，如果想改变chrome浏览器下的最小字体，可以使用 12font-size:12px;transform: scale(0.5); 当用户和Ctrl滚页面的时候（ctrl+，ctrl-），你会发现页面结构产生了不可预知的错乱，因此有人倡导使用em替代px 1.3 em介绍em是指相对于父元素的大小.简单的讲px是绝对单位，1px就是1px，2px就是2px，以此类推，而em是相对单位，em相对的基准点就是浏览器的字体大小，浏览器默认字体大小是16px，也就是1em默认等于16px，如果你想给某个文字设定为14px，就这样写 font-size:0.875em. 你可以在根节点上重定义基准字号 html {font-size:62.5%} ，此时页面基准字号就是 16px * 62.5% = 10px , 那么此时 1em = 10px，那么此时14px = 1.4em，15px=1.5em，依次类推。 em准确的说是相对于父节点的字号来计算的，在整个页面内1em并不是一个固定不变的值，1em不停的变换。所以这个地方比较蛋疼不建议采用。 1.4 rem的介绍rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 二、rem在移动端开发中的使用2.1 什么情况下使用rem对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 在实际项目中，把与元素尺寸有关的css，如width,height,line-height,margin,padding等都以rem作为单位，这样页面在不同设备下就能保持一致的网页布局。 2.2 一种老式的自适应解决方案rem配置参考，适合视觉稿宽度为640px的： 1&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt; 12345678html&#123;font-size:10px&#125;/*默认配置*/@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125; 例如在我在笔记本屏幕下面123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html class=&quot;narrow-screen&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;&lt;title&gt;rem参考案例&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;*&#123;padding: 0;margin: 0;&#125;html&#123;font-size:10px&#125;/*默认配置*/@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125;/*使用px前的代码.btn&#123;display:block;width: 250px;height:42px;line-height:42px;border-radius:5px;text-align:center;font-size:18px;background-color:#04BE02;color:#FFFFFF;margin: 50px;&#125;*/.btn&#123;display:block;width: 25rem;height:4.2rem;line-height:4.2rem;border-radius:0.5rem;text-align:center;font-size:1.8rem;background-color:#04BE02;color:#FFFFFF;margin: 5rem;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;btn&quot;&gt;拖动缩放窗口看下我的变化&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; a的长度为625px，设置的为25rem。换算规则就是先查询媒介，得到最小宽度大于800px，所以默认的html的字体大小是25px == 1rem。那么btn这个class的width属性为25*25 = 625px。 以上代码乍看没啥问题，响应式设计不就应该是这么干的吗？但是从工作量和复杂度方面来考虑，它有以下几个不足： .item类在所有设备下的width都是3.4rem，但在不同分辨率下的实际像素是不一样的，所以在有些分辨率下，width的界面效果不一定合适，有可能太宽，有可能太窄，这时候就要对width进行调整，那么就需要针对.item写媒介查询的代码，为该分辨率重新设计一个rem值。然而，这里有7种媒介查询的情况，css又有很多跟尺寸相关的属性，哪个属性在哪个分辨率范围不合适都是不定的，最后会导致要写很多的媒介查询才能适配所有设备，而且在写的时候rem都得根据某个分辨率html的font-size去算，这个计算可不见得每次都那么容易，比如40px / 23.5px，这个rem值口算不出来吧！由此可见这其中的麻烦有多少。 以上代码中给出的7个范围下的font-size不一定是合适的，这7个范围也不一定合适，实际有可能不需要这么多，所以找出这些个范围，以及每个范围最合适的font-size也很麻烦 设计稿都是以分辨率来标明尺寸的，前端在根据设计稿里各个元素的像素尺寸转换为rem时，该以哪个font-size为准呢？这需要去写才能知道。 2.3 网易新闻的自适应实现先来看看网易在不同分辨率下，呈现的效果： 从上面几张图可以看出，随着分辨率的增大，页面的效果会发生明显变化，主要体现在各个元素的宽高与间距。能够达到这种效果的根本原因就是因为网易页面里除了font-size之外的其它css尺寸都使用了rem作为单位。 可是在上部分提到，使用rem布局结合在html上根据不同分辨率设置不同font-size有很多不好解决的麻烦，网易是如何解决的呢？最根本的原因在于，网易页面上html的font-size不是预先通过媒介查询在css里定义好的，而是通过js计算出来的，所以当分辨率发生变化时，html的font-size就会变，不过这得在你调整分辨率后，刷新页面才能看得到效果。你看代码就知道为啥font-size是直接写到html的style上面的了（js设置的原因）： 它是根据什么计算的，这就跟设计稿有关了，拿网易来说，它的设计稿应该是基于iphone6，所以它的设计稿竖直放时的横向分辨率为750px，为了计算方便，取一个100px的font-size为参照，那么body元素的宽度就可以设置为width: 7.5rem，于是html的font-size=deviceWidth / 7.5。这个deviceWidth就是viewport设置中的那个deviceWidth。根据这个计算规则，可得出html的font-size大小如下：123deviceWidth = 320，font-size = 320 / 7.5 = 42.6667pxdeviceWidth = 375，font-size = 375 / 7.5 = 50pxdeviceWidth = 414，font-size = 414 / 7.5 = 55.2px 这个deviceWidth通过document.documentElement.clientWidth就能取到了，所以当页面的dom ready后，做的第一件事情就是：1document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px'; 这个7.5怎么来的，当然是根据设计稿的横向分辨率/100得来的。下面总结下网易的这种做法： 先拿设计稿竖着的横向分辨率除以100得到body元素的宽度： 布局时，设计图标注的尺寸除以100得到css中的尺寸，比如下图： 播放器高度为210px，写样式的时候css应该这么写：height: 2.1rem。之所以取一个100作为参照，就是为了这里计算rem的方便！ 在dom ready以后，通过以下代码设置html的font-size: font-size可能需要额外的媒介查询，并且font-size不能使用rem，如网易的设置： 1234567891011@media screen and (max-width:321px)&#123; .m-navlist&#123;font-size:15px&#125;&#125;@media screen and (min-width:321px) and (max-width:400px)&#123; .m-navlist&#123;font-size:16px&#125;&#125;@media screen and (min-width:400px)&#123; .m-navlist&#123;font-size:18px&#125;&#125; 视口要如下设置： 1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1, minimum-scale=1&quot;&gt; 当deviceWidth大于设计稿的横向分辨率时，html的font-size始终等于横向分辨率/body元素宽： 123var deviceWidth = document.documentElement.clientWidth;if(deviceWidth &gt; 750) deviceWidth = 750;document.documentElement.style.fontSize = deviceWidth / 7.5 + &apos;px&apos;; 之所以这么干，是因为当deviceWidth大于750时，则物理分辨率大于1500（这就看设备的devicePixelRatio这个值了），应该去访问pc网站了。事实就是这样，你从手机访问网易，看到的是触屏版的页面，如果从pad访问，看到的就是电脑版的页面。如果你也想这么干，只要把总结中第三步的代码稍微改一下就行了： 三、总结暂时还未总结完成，没有总结。 五、参考文档1.http://www.zhihu.com/question/320110952.http://screensiz.es/phone3.http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/4.http://www.cnblogs.com/PeunZhang/p/3407453.html5.http://www.codeceo.com/article/font-size-web-design.html","tags":[{"name":"css","slug":"css","permalink":"http://kavinforever.github.io/tags/css/"},{"name":"rem","slug":"rem","permalink":"http://kavinforever.github.io/tags/rem/"},{"name":"css3","slug":"css3","permalink":"http://kavinforever.github.io/tags/css3/"}]},{"title":"Hello World","date":"2016-07-30T06:39:38.000Z","path":"2016/07/30/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]